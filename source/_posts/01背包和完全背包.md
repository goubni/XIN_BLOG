---
title: 01背包 和 完全背包
excerpt: 无
tags: dp
categories: 背包系列
quicklink: true
date: 2023-11-28 09:16:00

---



# 01背包

## 问题

一个容量为m公斤的背包，现在有n种物品，<span style="color:blue">每种物品只有一件</span>，它们的重量分别为$w_i$，它们的价值分别为$c_i$，求能够放入背包的最大价值



## 输入

第一行：两个整数，n和m分别代表物品数量和背包容量

第2...n+1行：每行两个整数$W_i,C_i$,表示每个物品的重量和价值





背包问题老是会忘记，这个方程我都快忘了3遍都有了！！！！



# 思路

我们考虑状态变量 $f[i][j]$ 前$i$件物品放入容量为 $j$ 的背包的最大价值。

- 当前背包容量为j的时候，我们需要考虑第i件物品，<span style="color:red">能否放入，是否放入？</span>
  
  1. 如果当前背包容量有 $j<w[i]$ ，明显不能放入，此时 $f[i][j]=f[i-1][j]$ ，这很好理解，不能放入，那现在的最大价值就是放入之前的最大价值
  
  2. 如果有 $j>=w[i]$，此时是有能力放进去的，那到底要不要放？这分两种情况
     
     1. 假设不放,那就有 $f[i][j]=f[i-1][j]$
     
     2. 假设放，那就有 $f[i][j]=f[i-1][j-w[i]]+c[i]$，放的话，那么背包容量就得相应减少,即$j-w[i]$，价值得相应增加，即$+c[i]$
     
     3. 针对以上两种放或不放的情况，我们将他们比较一下就可以知道是选那种更优了,所以得出 $f[i][j]=max(f[i-1][j],f[i-1][j-w[i]+c[i])$
  
  3. 于是可以得出核心的递推代码
     
     ```cpp
     for(int i=1;i<=n;i++){ //枚举的是物品i
         for(int j=1;j<=m;j++){  //枚举的是容量
             if(j<w[i]) f[i][j]=f[i-1][j];
             else f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+c[i]);
         }
     }
     cout << f[n][m] << endl;
     ```

> 这段代码的时间复杂度和空间复杂度都是$O(nm)$



## 空间优化

空间还能进一步优化，优化过程很玄乎。

```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=w[i];j--){
        f[j]=max(f[j],f[j-w[i]]+c[i]);
    }
}
cout << f[m] << endl;
```

以防又忘记优化过程，我决定记下：01背包优化，容量倒着枚举，下界是重量。









# 完全背包

上面的就是在可以放进物品的情况下，有放 0,1个物品两种选择

而完全背包则是，物品有无限个，即有放 0,1,2,3.... 很多种选择，这个时候再问你最大价值是多少？





这两者的状态转移方程优点小像

1. 当 $j<w[i]$ ，不能放任何物品进去 , $f[i][j]=f[i-1][j]$

2. 当 $j>=w[i]$，可以放物品进去,$f[i][j]=max(f[i][j-w[i]]+c[i],f[i-1][j])$这个怎么理解，因为物品可以放无限个，对于前i件物品，背包容量为$j-w[i]$时可能已经放入了第$i$件物品，容量为j时，还可以再放一件这样的物品

```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(j<w[i]) f[i][j]=f[i-1][j];
        else f[i][j]=max(f[i-1][j],f[i][j-w[i]+c[i]);
    }
}
cout << f[m][n];
```



## 优化

01背包的空间优化口诀：容量倒着枚举，下界是重量



完全背包的空间优化口诀是：容量正着枚举，初始是重量

```cpp
for(int i=1;i<=n;i++){
    for(int j=w[i];j<=m;j++){
        f[j]=max(f[j],f[j-w[i]]+c[i]);
    }
}
cout << f[m];
```







分清楚这两种背包

> 01背包 $f[i][j]=max(f[i-1][j-w[i]]+c[i],f[i-1][j])$

> 完全背包 $f[i][j]=max(f[i][j-w[i]]+c[i],f[i-1][j])$



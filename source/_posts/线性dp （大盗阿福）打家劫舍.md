---
title: 线性dp 打家劫舍
excerpt: 无
tags: dp
categories: 线性dp系列
quicklink: true
date: 2023-12-4 09:16:00
---

# 线性dp （大盗阿福）打家劫舍

## 题目

阿福是一名经验丰富的大盗，趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。一共有N家店铺，每一家店中都有一些现金。阿福事先调查得知，只有当他同时洗劫了1两家相邻店铺时，他会被抓。他想知道在不惊动警察的情况下，最多可以得到多少现金

输入样例： 

3

1 8 2 明显答案是8，只需要偷第二家店铺就可以价值最大

## 思路1

- 状态表示：$f[i]$表示偷前$i$家店铺能获得的最大值

- 不偷当前这家店铺的时候,只能由前面的状态原封不动转移过来,即$f[i]=f[i-1]$

- 偷这家店铺的时候，只能由前两家店铺的状态加上金额转移过来，即$f[i]=f[i-2]+w[i]$

- 然后再比较这两种情况谁更大，于是得出了总的状态转移方程$f[i]=max(f[i-1],f[i-2]+w[i]$

- 初始化，f[0]=0,f[1]=w[1]，第0家，啥也没有，所以能偷的是0，第一家能偷的是w[1]。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,w[1001],f[1001];
int main(){
    cin >> n;
    for(int i=1;i<=n;i++)cin>>w[i];
    f[0]=0;f[1]=w[1];
    for(int i=2;i<=n;i++){
        f[i]=max(f[i],f[i-2]+w[i]);
    }
    cout << f[n];
    return 0;
} 
```

## 思路2

以上是一种思路，还有另外一种递推的思路

- 状态表示:$f[i][0]$表示不偷第i家的利润最大值,$f[i][1]$表示偷第i家的利润最大值

- f[i][0] 可以从前一家店铺的偷与不偷转移过来,即$f[i][0]=max(f[i-1][0],f[i-1][1])$

- f[i][1]可以从前一家店铺的不偷转移过来，
  
  $f[i][1]=f[i-1][0]+w[i]$

状态转移方程确定好了之后，再考虑边界初值就可以了

- 不偷第1家店铺 f[1][0] = 0

- 偷第1家店铺 f[1][1]=w[1]

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,w[1001],f[1001][2];
int main(){
    cin >> n;
    for(int i=1;i<=n;i++)cin>>w[i];
    f[1][0]=0;f[1][1]=w[1];
    for(int i=2;i<=n;i++){
        f[i][0]=max(f[i-1][0],f[i-1][1]);
        f[i][1]=f[i-1][0]+w[i];
    }
    cout << max(f[n][0],f[n][1]);
    return 0;
} 
```

## 总结

> 思路1是分步转移，思路2是分类转移。分类转移更好一些。

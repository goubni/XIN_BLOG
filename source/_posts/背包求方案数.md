---
title: 背包问题方案数
excerpt: 无
tags: dp
categories: 背包系列
quicklink: true
date: 2023-12-2 09:16:00

---

## 题目

有N件物品和一个容量是M的背包，每件物品只能使用一次。第i件物品体积是$v_i$，价值是$c_i$

求解将哪些物品装入背包，可是这些物品的总体积不超过背包容量，且总价值最大。输出最优选法的方案数，注意答案很大，取模1e9+7

## 解法

$f[i]$代表背包容量为i时能装入物品的最大价值

$c[i]$代表背包容量为i时的最优选法的方案数，那初始情况，啥也不装也是一种情况

```cpp
cin >> n >> m;
for(int i=1;i<=n;i++) c[i]=1; //初始化

for(int i=1;i<=n;i++){
    cin >> v >> c;
    for(int j=m;j>=v;j--){
        if(f[j-v]+c>f[j]){
            f[j]=f[j-v]+c;
            c[j]=c[j-v];
        }else if(f[j-v]+w==f[j]){
            c[j]=(c[j]+c[j-v])%mod;
        }
    }
}
cout << c[m];
```

- 当可以选这个物品的时候，并且也满足f[j-v]+c>f[j]，意味着可以把这个物品放入背包，而对方案数来说，没有什么变化，只是从背包容量为j-v时的方案数转移到了j时的方案数,于是 $c[j]=c[j-v]$

- 如果当前物品放入背包，发现价值没有增加 $f[j-v]+w=f[j]$，那此时，既可以放入新物品$c[j-v]$，也可以不放入$c[j]$，两种情况，显然不同，所以取和。

## 怎样求解其他背包的方案数？

只要循环那一层改一下，for(int j=v;j<=m;j++) 就是完全背包的方案数。其他的照搬

## 怎样求解恰好装满01背包，且最优选法的方案数

只要略微改动初始化就可以了

上面的那种是不超过容量的求法，这种是刚刚好装满背包的初始化

```cpp
cin >> n >> m;
for(int i=1;i<=m;i++) f[i]= 负无穷; //初始化
f[0]=0,c[0]=1;
for(int i=1;i<=n;i++){
    cin >> v >> c;
    for(int j=m;j>=v;j--){
        if(f[j-v]+c>f[j]){
            f[j]=f[j-v]+c;
            c[j]=c[j-v];
        }else if(f[j-v]+w==f[j]){
            c[j]=(c[j]+c[j-v])%mod;
        }
    }
}
cout << c[m];
```

只改动了f数组，将他们初始置为负无穷，只初始化了背包体积为0时的方案数

只有恰好装满时，才有机会通过c[0]直接或间接转移，方案数才可能增加

## 举个例子

[P2563 [AHOI2001] 质数和分解 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2563)

这题，很好做，思路很明了，明显就是一个完全背包，先把200以内的质数晒出来，题目就转换成了，从这堆质数里，任意质数可以拿出无限个，求刚刚好装满背包的方案数。背包的容量，自然是200。递推出c后，也就得到了2到200的所有方案数

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[210],pri[201],vis[201],cnt,t,c[210];

void init(){
    for(int i=2;i<=200;i++){
        if(!vis[i])pri[++cnt]=i;
        for(int j=1;j<=cnt&&pri[j]*i<=200;j++){
            vis[pri[j]*i]=1;
            if(i%pri[j]==0)break;
        } 
    }
}


int main(){
    init();
    for(int i=0;i<=200;i++)f[i]=-1000;
    f[0]=0,c[0]=1;
    for(int i=1;i<=cnt;i++){
        int v = pri[i];
        for(int j=v;j<=200;j++){
            if(f[j-v]>f[j]){
                f[j]=f[j-v];
                c[j]=c[j-v];
            }else if(f[j-v]==f[j]){
                c[j]=(c[j]+c[j-v]);
            }
        }
    }
    while(cin >> t){
        cout << c[t] << endl;
    }
    return 0;
}
```

注意我的f和c的初始化细节，当然这题可以有更好的解法求方案数，那就是直接将f数组定义为方案数，但是这样我怕乱套，还是按部就班来，以后求方案数，先判断要不要装满，装满的初始化(f负无穷除了0,c[0]=1)，没装满(c[i]=1)。

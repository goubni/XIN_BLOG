---
title: 树形dp 没有上司的舞会
excerpt: 无
tags: dp
categories: 树形dp系列
quicklink: true
date: 2023-12-10 23:16:00

---



之前看到一位佬说的：树形dp是一种很优美的动态规划，真的很优美真的，前提是在你学会它之后😭😭😭。





题目链接：[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1352)



# 没有上司的舞会

## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 输入格式

输入的第一行是一个整数 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。

第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。

## 输出格式

输出一行一个整数代表最大的快乐指数。

## 样例 #1

### 样例输入 #1

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

### 样例输出 #1

```
5
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。







# 思路

这里我们得将$dfs$和动态规划结合起来去做，真的很优雅，优雅的代码赏心悦目。题意很明显，当我们建好了一颗树之后，要如何选择这些结点才可以使开心值最大化。如果选了一个结点，那么它的所有儿子都不能选；如果不选这个结点，那么它的所有儿子既可以选也可以不选。我们设$f[i][0]$是以i结点为根节点的子树并且不选这个结点时的开心值，$f[i][1]$是以i结点为根节点的子树并且选这个结点时的开心值。

可以得出以下的关系,设u是父节点，v是子节点

- $f[u][1] = \sum f[v][0]$，很好理解，你父节点选，那你子节点统统不能选

- $f[u][0]=\sum max(f[v][1],f[v][0])$，父节点不选，就在子节点中选与不选比较



> 树形dp通常都是要用dfs,从根到叶，从叶到根，在合适的时候dp

核心代码:dp的过程是从树下向树上的过程

```cpp
void dfs(int u){
	f[u][1] = w[u]; //初始化开心值
	for(int x:e[u]){
		dfs(x);	 //一直向下搜
		f[u][0]+=max(f[x][0],f[x][1]);
		f[u][1]+=f[x][0];
	}	
}
```

太优雅了啊！！我什么时候才能自己写出这么优雅的代码😭😭😭





代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[6010][2],w[6010],x,y;
//f[i][0]代表以i为子树的树不选的时候的最大代价
//f[i][1]代表以i为子树的树选的时候的最大代价 
vector<int> e[6010];
int vis[6010];
void dfs(int u){
	f[u][1] = w[u];
	for(int x:e[u]){
		dfs(x);	
		f[u][0]+=max(f[x][0],f[x][1]);
		f[u][1]+=f[x][0];
	}	
}

int main(){
	cin >> n;
	for(int i=1;i<=n;i++) cin >> w[i];
	for(int i=1;i<=n-1;i++){
		cin >> x >> y;
		vis[x]=1;
		e[y].push_back(x);
	}
	int root=1;
	while(vis[root])root++;
	dfs(root);
	cout << max(f[root][0],f[root][1]);
	return 0;
}
```



> 树形dp真优雅

---
title: 线性DP 数字三角形
excerpt: 关于数字三角形的线性DP
tags: dp
categories: dp题型
quicklink: true
date: 2023-10-24 23:45:00

---

# 概述

给你一个数塔，像这样子的        $1\\4,6\\8,3,9\\5,7,2,1$

然后告诉你每一个数可以选择加上它下面那个数或者下面那个数右边的数，问最大的那个数是多少。这是一道很简单的动态规划题，转移方程一眼就可以得出是 $dp[i][j] = dp[i][j]+min(dp[i+1][j],\ dp[i+1][j+1])$，这个答案也很快能得出

```cpp
//数塔-从下向上推出，找到最大和，找到最大和的路径 a[i][j] = min(a[i+1][j],a[i+1][j+1]) +a[i][j];
    for(int i = 2; i >= 0 ; i--){
        for(int j = 0; j <= i; j++){
            a[i][j] += max(a[i+1][j],a[i+1][j+1]);
        }
    }
    //找到最大值 
    cout << a[0][0] << endl; 
    //输出答案20
```

那现在要求你得记录下这个最大的值的生成路径，就是这个最大值是怎么来的，这个例子里可以看出是 $1 - 4-8-7$，那要怎么记录这个路径呢，记住了，遇到这种记录路径的，开一个<mark>记录路径增量的数组p</mark>，<mark>开一个备份数组b</mark>，并使状态转移对应增量的变化

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[4][4] = {
        {1},
        {4,6},
        {8,3,9},
        {5,7,2,1}, 
    };

int b[4][4]; //用于备份a数组
int p[4][4]; //用于记录路径增量的数组


int main(){
    //找到最大值的路径 
    for(int i=0;i<4;i++){
        for(int j=0;j<=i;j++){
            b[i][j] = a[i][j];
        }
    }
    for(int i = 2; i >= 0; i--){
        for(int j = 0; j <= i; j++){
            if(a[i+1][j] > a[i][j]){
                a[i][j] += a[i+1][j];
                //将路径增量置为0
                p[i][j] = 0; 
            } else {
                a[i][j] += a[i+1][j+1];
                //将路径增量置为1
                p[i][j] = 1; 
            }
        }
    }
    //输出路径 
    for(int i = 0, j = 0; i < 4; i++){
        cout << b[i][j] << "->";
        //使j加上偏移量，可正确偏移 
        j += p[i][j];
    }
    return 0;
}
//输出结果：1->4->8->7->
```

---
title: 多重背包
excerpt: 多重背包呦呦呦
tags: dp
categories: 背包系列
quicklink: true
date: 2023-11-29 06:16:00

---

# 题目模板

有n种物品和一个容量为$m$的背包。第$i$种物品最多有$s_i$件，每件体积是$v_i$，价值是$w_i$。求解选择哪些物品放入背包，使得物品体积总和不超过背包容量，且价值总和最大。输出最大价值

## 输入

第一行输入两个整数$n$和$m$，分别表示物品种数和背包容量。接下来有$n$行，每行三个整数$v_i,c_i,s_i$，分别表示第$i$种物品的体积、价值和数量

eg：3 7

    2 3 12

    3 5 15

    1 2 3

# 思路

回想之前学过的两种背包，一种非常常规的01背包,一种是和01背包代码特别像的完全背包，前面就说过了这两种背包的区别

01背包：可以放物品的时候，我们可以选择放 0件，1件

完全背包： 可以放物品的时候，我们可以选择放 0,1,2,.... 件

<span style="color:red">多重背包: 可以放物品的时候，我们可以选择放 0,1,...$s_i$件</span>

那么我们可以把多重背包转换为01背包求解：把第$i$种物品换$s_i$件01背包中的物品,每件物品的体积为 $k*v_i$，价值为$k*c_i$

```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=v[i];j--){
        for(int k=0;k<=s[i]&&k*v[i]<=j;k++){
            f[j]=max(f[j],f[j-k*v[i]]+k*w[i]);
        }
    }
}
```

时间复杂度$O(m\sum s_i)$

这是朴素解法，时间复杂度会有点大，但是可以在此基础上进行优化

## 二进制优化

首先，我们随便拿出一个正整数，都可以几个$2^k$的数相加得到，比如

$5 = 2^2+2^0$

$6=2^2+2^1$

..........

二进制优化思想：

将第i种物品拆分成若干种物品，每件物品的体积和价值乘以一个拆分系数($1,2^1,2^2...2^{k-1},s_i-2^k+1$)，就可以转换成01背包中的物品求解。

比如$s_i=12$，拆分系数为1，2，4，5，就转换成4件01背包的物品:$(v_i,w_i),(2v_i,2w_i),(4v_i,4w_i),(5v_i,5w_i)$

二进制拆分过程

```cpp
int num=1;//拆分计数
for(int i=1;i<=n;i++){
    //v,c,s;体积，价值，数量
    cin >> v >> c >> s;

    //二进制拆分
    for(int j=1;j<=s;j<<=1){
        vv[num]=j*v; //存体积
        cc[num++]=j*c; //存价值
        s-=j;
    }
    if(s){
        //还有剩余
        vv[num]=s*v;
        cc[num++]=s*c;
    }
}
```

转换成01背包

```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=vv[i];j--){
        f[j]=max(f[j],f[j-vv[i]]+cc[i]);
    }
}
cout << f[m];
```

时间复杂度降到了$O(m\sum\log s_i)$

这样多重背包问题就~~轻松~~解决了

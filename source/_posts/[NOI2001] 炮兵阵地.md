---
title: 状压dp 炮兵阵地
excerpt: 无
tags: dp
categories: 状压dp系列
quicklink: true
date: 2023-12-6 23:16:00

---

# [NOI2001] 炮兵阵地

## 题目描述

司令部的将军们打算在 $N\times M$ 的网格地图上部署他们的炮兵部队。

一个 $N\times M$ 的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地（用 $\texttt{H}$ 表示），也可能是平原（用 $\texttt{P}$ 表示），如下图。

在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：

 ![](https://cdn.luogu.com.cn/upload/pic/1881.png) 

如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。

图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。

现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。

## 输入格式

第一行包含两个由空格分割开的正整数，分别表示 $N$ 和 $M$。

接下来的 $N$ 行，每一行含有连续的 $M$ 个字符，按顺序表示地图中每一行的数据。

## 输出格式

一行一个整数，表示最多能摆放的炮兵部队的数量。

## 样例 #1

### 样例输入 #1

```
5 4
PHPP
PPHH
PPPP
PHPP
PHHP
```

### 样例输出 #1

```
6
```

## 提示

对于 $100\%$ 的数据，$1 \leq N\le 100$，$1 \leq M\le 10$，保证字符仅包含 `P` 与 `H`。

# 思路

- 思考一行有多少种状态，用二进制表示的话，假设n是4，一共有 <mark>0000</mark>,<mark>0001</mark>,<mark>0010</mark>,0011,<mark>0100</mark>,0101,0110,0111,<mark>1000</mark>,<mark>1001</mark>,1010,1011,1100,1101,1110,1111。一共16种状态，其中高亮部分是合法的状态，代码表示`!(i&i>>1)&&!(i&i>>2)`

- 思考行间是否兼容

| c:  | <span style="color:red">1</span> | 0                                | 0                                | <span style="color:red">1</span> |
| --- | -------------------------------- | -------------------------------- | -------------------------------- | -------------------------------- |
| b:  | 0                                | <span style="color:red">1</span> | 0                                | 0                                |
| a:  | 0                                | 0                                | <span style="color:red">1</span> | 0                                |

由图可以看出，我们枚举a的时候，发现这三行得兼容，只要它们相互之间没有同一列是1就可以了,即`!(a&b)&&!(b&c)&&!(a&c)`；题目也说了有地形限制，就意味着即使有些是合法状态，但是由于地形原因是不可用的，即`a&g[i]==a`表示地形匹配。

- 状态表示，太厉害了，~~蒟蒻没做过不可能想得出来~~，$f[i][a][b]$表示已经摆放前i行，当前是第a个状态，并且是第i-1行b第b个状态时，<mark>能摆放的最大数量</mark>，$f[i][a][b]=max(f[i][a][b],f[i-1][b][c]+num[a])$

- 最大数量: $ans=max(f[n][a][b])$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,cnt;
char x;
int s[1<<13],num[1<<13],g[110],f[12][1<<11][1<<11];
//f[i][a][b]代表摆到第i行时，第a个状态，第i-1行时第b个状态的数量 
int main(){
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin >> x;
            if(x=='P') g[i]=(g[i]<<1)+1;
            else g[i]<<=1;
        } 
    }
    for(int i=0;i<(1<<m);i++){
        if(!(i&i>>1)&&!(i&i>>2)){
            s[cnt++]=i;
            for(int j=0;j<m;j++){
                num[i] += (i>>j&1);
            }
        }
    }
    //求数量
    for(int i=1;i<=n;i++){
        for(int a=0;a<cnt;a++){
            for(int b=0;b<cnt;b++){
                for(int c=0;c<cnt;c++){
                    if(!(s[a]&s[b])&&!(s[a]&s[c])&&!(s[b]&s[c])&&(s[a]&g[i])==s[a]){
                        f[i][a][b]=max(f[i][a][b],f[i-1][b][c]+num[s[a]]);
                    }
                }
            }
        }
    }
    int ans=0;
    for(int i=0;i<cnt;i++){
        for(int j=0;j<cnt;j++){
            ans = max(f[n][i][j],ans);
        }
    }
    cout << ans;
    return 0;
}
```

滚动数组优化

```cpp

```

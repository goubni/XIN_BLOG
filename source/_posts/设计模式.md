---
title: 设计模式
excerpt: 来学设计模式
tags: 设计模式
categories: 设计模式 
quicklink: true
date: 2023-10-16 10:28:00
update: 2023-10-16 22:00:00    
---

# 概述

## 为什么要学设计模式

1. 软考要考 （bushi）

2. 设计模式来源于众多专家的经验和智慧，使用这些方案可以让我们避免做一些重复性的工作，有助于我们提高开发和设计效率

3. 设计模式跨语言、跨平台、跨应用，方便开发人员交流

4. 学习设计模式将有助于初学者更加深入地理解面向对象思想。

先了解几种面向对象地设计原则:

## 面向对象设计原则

| 设计原则名称 | 定义                        | 使用频率 |
|:------:|:-------------------------:|:----:|
| 单一职责原则 | 一个类只负责一个功能领域中的相应职责        | 高    |
| 开闭原则   | 软件实体应对扩展开放，而对修改关闭         | 高    |
| 里氏代换原则 | 所有引用基类对象的地方都能够透明地使用其子类地对象 | 高    |
| 依赖倒转原则 | 抽象不应该依赖于细节，细节应该依赖于抽象      | 高    |
| 接口隔离原则 | 使用多个专门地接口，而不使用单一地总接口      | 低    |
| 合成复用原则 | 尽量使用对象组合，而不是继承来达到复用地目的    | 高    |
| 迪米特法则  | 一个软件实体应当尽可能少地与其他实体发生      | 一般   |

### 单一职责原则

单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。一个类承担地责任越多，它被复用地可能性就越小。**单一职责原则是实现<mark>高内聚低耦合</mark>地指导方针**

eg:给出一个客户类的设计

```java
class Customer {
    //连接数据库
    public void getConnection(){}
    //寻找客户
    public Object findCustomer(){}
    //创建产品
    public Object createproduct(){}
    //展示产品
    public void displayproduct(){}
}
```

现在要你用单一职责原则来重构这一段代码

来看看这段代码的问题：Customer类承担了太多职责，它既有连接数据库的方法，也有寻找客户的方法，如果其他的类中也有需要这些方法的时候，则代码难以重用。因此可以对这个类进行拆分，来满足单一职责原则。可以将这个类拆成3个类，DButil用于连接数据库，CustomerDAO用于findCustomer，Product用于创建和展示产品

```java
public class DBUtil {
    public void getConnection() {
        // 连接数据库的代码
    }
}

public class CustomerDAO {
    private DBUtil dbUtil;

    public CustomerDAO(DBUtil dbUtil) {
        this.dbUtil = dbUtil;
    }

    public Object findCustomer() {
        dbUtil.getConnection();
        // 客户查找的代码
        return null;
    }
}

public class Product {
    public Object createProduct() {
        // 创建产品的代码
        return null;
    }

    public void displayProduct() {
        // 展示产品的代码
    }
}

public class Customer {
    private DBUtil dbUtil;
    private CustomerDAO customerDAO;
    private Product product;

    public Customer(DBUtil dbUtil, CustomerDAO customerDAO, Product product) {
        this.dbUtil = dbUtil;
        this.customerDAO = customerDAO;
        this.product = product;
    }

    public void connectToDB() {
        dbUtil.getConnection();
    }

    public Object findCustomer() {
        return customerDAO.findCustomer();
    }

    public Object createProduct() {
        return product.createProduct();
    }

    public void displayProduct() {
        product.displayProduct();
    }
}
```

这样重构之后，每个类都有自己的作用，Customer现在依赖DBUtil，Product，CustomerDAO，需要时通过构造函数注入，这种设计方式代码复用性强，如果还有别的类需要这样的功能，就直接调方法就可以了

### 开闭原则

开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

先来看一段代码

```java
public class ChartDisplay {
    public void display(String type) {
        if (type.equals("pie")) {
            PieChart chart = new PieChart();
            chart.display();
        } else if (type.equals("bar")) {
            BarChart chart = new BarChart();
            chart.display();
        }
    }
}

public class PieChart {
    public void display() {
        // 显示饼状图的代码
    }
}

public class BarChart {
    public void display() {
        // 显示柱状图的代码
    }
}
```

可以看出display这个方法是判断传进来的字符串是什么类型，再来创建折线图对象。这样的设计方式弊端很大：如果新增加了一个类LineChart，那么这段代码的display部分就必须修改逻辑，这就违法了开闭原则。现在对这段代码进行重构

```java
public abstract class AbstractChart {
    public abstract void display();
}

public class ChartDisplay {
    private AbstractChart chart;
    public void setChart(AbstractChart chart) {
        this.chart = chart;
    }

    public void display() {
        chart.display();
    }
}

public class PieChart extends AbstractChart {
    public void display() {
        // 显示饼状图的代码
    }
}

public class BarChart extends AbstractChart {
    public void display() {
        // 显示柱状图的代码
    }
}

// 新增的折线图类
public class LineChart extends AbstractChart {
    public void display() {
        // 显示折线图的代码
    }
}
```

不难看出，这会用到里式代换原则，先将图表抽象成一个类，再定义抽象方法display。

这样，如果需要增加一种新的图表，如折线图 `LineChart`，只需将 `LineChart` 作为 `AbstractChart` 的子类，然后在客户端向 `ChartDisplay` 中注入一个 `LineChart` 对象即可，无需修改现有类库的源代码。这符合开闭原则，对扩展是开放的，对修改是封闭的。

### 里式代换原则

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。

> 我个人认为学了javaSE中的多态这点可以自行理解

### 依赖倒转原则

**依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。**

学了Spring的这个也能秒懂的

依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，**尽量引用层次高的抽象层类，即使用接口和抽象类**进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。说通俗点就是针对抽象层来编程，将具体类的对象通过**依赖注入(DependencyInjection, DI)**的方式注入到其他对象中

示例代码

```java
// 抽象电梯接口
public interface Elevator {
    void moveUp();
    void moveDown();
}

// 电梯控制器类，依赖抽象电梯接口
public class ElevatorController {
    private Elevator elevator;

    public ElevatorController(Elevator elevator) {
        this.elevator = elevator;
    }

    public void goUp() {
        elevator.moveUp();
    }

    public void goDown() {
        elevator.moveDown();
    }
}

// 实现了抽象电梯接口的具体电梯类
public class SimpleElevator implements Elevator {
    public void moveUp() {
        System.out.println("SimpleElevator: Moving up");
    }

    public void moveDown() {
        System.out.println("SimpleElevator: Moving down");
    }
}

// 高级电梯类，也实现了抽象电梯接口
public class AdvancedElevator implements Elevator {
    public void moveUp() {
        System.out.println("AdvancedElevator: Moving up");
    }

    public void moveDown() {
        System.out.println("AdvancedElevator: Moving down");
    }
}
```

这里我们针对抽象层编程体现在 `private Elevator e;`,再通过构造方法将传入的对象注入进这个e中，会发现，这里又体现了里氏代换原则。在示例中，我们有一个 `SimpleElevator` 类和一个 `AdvancedElevator` 类，它们都实现了抽象电梯接口 `Elevator`。通过在电梯控制器类的构造函数中传入相应的具体电梯对象，我们就可以使用不同类型的电梯，而无需修改电梯控制器的源代码。这样，我们符合了依赖倒转原则，高层模块（`ElevatorController`）依赖于抽象（`Elevator`）而非具体实现，达到了解耦和灵活性的目的。

### 合成复用原则

**合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的**，是这样的，继承会导致子类父类紧密耦合，如果要修改父类的代码，子类也会收到影响，又会引发一系列问题，相比之下，组合提供了更灵活的方式来构建对象间的关系。

假设你有一个车Car，他有轮子(Wheel),有发动机(Engin),有车壳(kezi),用合成复用原则设计这辆车

代码示例

```java
public interface Component {
    String getDescription();
}
public class Engine implements Component {
    @Override
    public String getDescription() {
        return "Engine component";

    }
}
public class Wheel implements Component {
    @Override
    public String getDescription() {
        return "Wheel component";
    }
}
public class kezi implements Component {
    @Override
    public String getDescription() {
        return "kezi component";
    }
}
public class Car {
    private Component engine;
    private Component wheel;
    private Component steeringWheel;

    public Car() {
        engine = new Engine();
        wheel = new Wheel();
        steeringWheel = new SteeringWheel();
    }

    public String getDescription() {
        StringBuilder sb = new StringBuilder();
        sb.append("Car consists of:\n");
        sb.append(engine.getDescription()).append("\n");
        sb.append(wheel.getDescription()).append("\n");
        sb.append(steeringWheel.getDescription()).append("\n");
        return sb.toString();
    }
}
```

测试类

```java
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        String description = car.getDescription();
        System.out.println(description);
    }
}
```

> 通过组合关系，我们可以将若干个对象组合在一起，形成一个新的对象，从而实现代码灵活性

### 迪米特法则

暂略

### 接口隔离原则

暂略

<br>

# 初始-了解简单工厂模式

简单工厂模式并不在23种设计模式的范畴种，但是一个经常用的到，入门必学的模式。

案例：用java开发一套图表库，该图表库可以提供各种不同外观的图表，例如柱状图、饼状图、折线图等。希望能开发出一套灵活的图表库，而且可以扩展，以便之后加入一些新类型的图表

初始化方案：

```java
class Chart {
    private String type; //图表类型

    public Chart(Object[][] data, String type) {
        this.type = type;
        if (type.equalsIgnoreCase("histogram")) {
            //初始化柱状图
        }
        else if (type.equalsIgnoreCase("pie")) {
            //初始化饼状图
        }
        else if (type.equalsIgnoreCase("line")) {
            //初始化折线图
        }
    }

    public void display() {
        if (this.type.equalsIgnoreCase("histogram")) {
            //显示柱状图
        }
        else if (this.type.equalsIgnoreCase("pie")) {
            //显示饼状图
        }
        else if (this.type.equalsIgnoreCase("line")) {
            //显示折线图
        }    
    }
}
```

这个方案缺点有很多

1. Chart类的职责过重，它不仅要初始化，还要展示图表，这违法了**单一职责原则**，不利于类的重用和维护

2. 当新添加一个图表时，必须得修改Chart类的源代码，违反了**开闭原则**

3. 客户端只能通过new来直接创建Chart对象，Chart类于客户端类**耦合度高，对象的创建和使用无法分离**

如果用简单工厂模式，那就可以解决这一问题。

简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建图表对象，而在引入工厂类之后，客户端可以直接通过工厂类来创建对象。工厂类提供了一个静态方法供客户端使用，根据所传入的参数不同可以创建不同的图表对象。

这里我们先写一个Chart接口将图表抽象

```java
interface Chart{
    public void display();
}
//柱状图
class HistogramChart implements Chart{
    //实现display
}
class PieChart implements Chart{
    //实现display
}
class LineChart implements Chart{
    //实现display
}

//创建工厂类
class ChartFactory{
    //静态方法
    public static Chart getChart(String type){
        Chart chart = null;
        if (type.equalsIgnoreCase("histogram")){
            chart = new HistogramChart();
        } else if (type.equalsIgnoreCase("PieChart"){
            chart = new PieChart();
        } else if type.equalsIgnoreCase("LineChart"){
            chart = new LineChart();
        }
        return chart;
    }
}
```

这样在客户端要获取代码的时候就可以不用new了，耦合度就降低了

```java
class Main{
    public static void main(String []args){
         Chart chart = ChartFactory.getChart("histogram");   
         chart.display();    
    }
}
```

*用xml文件，可以实现ChartFactory.getChart("config.xml"),如果需要更换图表，甚至客户端代码都不需要改，符合"开闭原则"

总结：

> 简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建与使用分离开。
> 
> 主要优点：
> 
> 1. 客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离
> 
> 2. 引入配置文件，可以不修改客户端代码的情况下更换或增加新的产品类。
> 
> 缺点：
> 
> 1. 工厂类的职责过重，一旦停止工作，整个系统收到影响
> 
> 2. 系统扩展困难，一旦添加新的产品类，那工厂的逻辑就得再次修改
> 
> 3. 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。





# 工厂方法模式

工厂方法模式是简单工厂模式的大哥。先来说说简单工厂模式的缺点，它将所有产品创建的职责都集中在了Factory中，导致各种产品类与这个Factory紧密耦合。而且如果要增加新的产品，那么必须得改动Factory中的源代码，而且大量的if-else影响系统的效率。



工厂方法模式就能很好的解决这也问题，在工厂方法模式中，我们**不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构**



定义：**工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。**



案例：当你购买电脑时，需要选择不同品牌和型号的计算机。在这种情况下，工厂方法模式可以很好地应用。



```java
//定义一个抽象的电脑类，包含抽象方法compute计算
public abstract class computer{
    public abstract void compute();
}


//定义具体的产品类继承Computer
public class LenovoComputer extends Computer {
    @Override
    public void compute() {
        System.out.println("使用联想电脑进行计算");
    }
}

public class DellComputer extends Computer {
    @Override
    public void compute() {
        System.out.println("使用戴尔电脑进行计算");
    }
}


//定义一个抽象的电脑工厂，并包含一个抽象的工厂方法createComputer()\
public abstract class ComputerFactory {
    public abstract Computer createComputer();
}


//继续创建电脑的工厂LenovoFactory和DellFactory,它们都是ComputerFactory子类
public class LenovoFactory extends ComputerFactory {
    @Override
    public Computer createComputer() {
        return new LenovoComputer();
    }
}
public class DellFactory extends ComputerFactory {
    @Override
    public Computer createComputer() {
        return new DellComputer();
    }
}


//客户端测试
public class Client {
    public static void main(String[] args) {
        // 创建联想电脑
        ComputerFactory lenovoFactory = new LenovoFactory();
        Computer lenovoComputer = lenovoFactory.createComputer();
        lenovoComputer.compute(); // 输出：使用联想电脑进行计算

        // 创建戴尔电脑
        ComputerFactory dellFactory = new DellFactory();
        Computer dellComputer = dellFactory.createComputer();
        dellComputer.compute(); // 输出：使用戴尔电脑进行计算
    }
}


```



可以品到，简单工厂模式只是对产品进行抽象层编程，而工厂方法模式还对工厂进行抽象层编程，通过工厂方法模式，我们可以通过具体的工厂类来创建不同品牌的电脑对象，而不需要直接实例化具体的产品类。这样使得客户端代码与具体产品类解耦，也方便了后续的扩展和维护。

 

优点：

> 1. 工厂方法用来创建客户所需的产品，隐藏了具体产品类的实例化细节。
> 
> 2. 工厂角色和产品角色之间通过多态性设计实现解耦。
> 
> 3. 添加新产品时，无需修改抽象工厂和抽象产品接口，只需添加具体工厂和具体产品

缺点：

> 1. 添加新产品时，还要提供与之对应的工程类，系统中类的个数将会成对增加
> 
> 2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度













感谢大佬的教程，带我学习设计模式

[史上最全设计模式导学目录（完整版）_史上最全设计模式lovelion-CSDN博客](https://blog.csdn.net/LoveLion/article/details/17517213?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169743190816800222875841%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169743190816800222875841&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-17517213-null-null.142^v96^pc_search_result_base2&utm_term=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)

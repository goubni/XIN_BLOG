---
title: 设计模式
excerpt: 来学设计模式
tags: 设计模式
categories: 设计模式 
quicklink: true
date: 2023-10-16 10:28:00
update: 2023-10-16 22:00:00    
---

# 概述

## 为什么要学设计模式

1. 软考要考 （bushi）

2. 设计模式来源于众多专家的经验和智慧，使用这些方案可以让我们避免做一些重复性的工作，有助于我们提高开发和设计效率

3. 设计模式跨语言、跨平台、跨应用，方便开发人员交流

4. 学习设计模式将有助于初学者更加深入地理解面向对象思想。

先了解几种面向对象地设计原则:

## 面向对象设计原则

| 设计原则名称 | 定义                        | 使用频率 |
|:------:|:-------------------------:|:----:|
| 单一职责原则 | 一个类只负责一个功能领域中的相应职责        | 高    |
| 开闭原则   | 软件实体应对扩展开放，而对修改关闭         | 高    |
| 里氏代换原则 | 所有引用基类对象的地方都能够透明地使用其子类地对象 | 高    |
| 依赖倒转原则 | 抽象不应该依赖于细节，细节应该依赖于抽象      | 高    |
| 接口隔离原则 | 使用多个专门地接口，而不使用单一地总接口      | 低    |
| 合成复用原则 | 尽量使用对象组合，而不是继承来达到复用地目的    | 高    |
| 迪米特法则  | 一个软件实体应当尽可能少地与其他实体发生      | 一般   |

### 单一职责原则

单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。一个类承担地责任越多，它被复用地可能性就越小。**单一职责原则是实现<mark>高内聚低耦合</mark>地指导方针**

eg:给出一个客户类的设计

```java
class Customer {
    //连接数据库
    public void getConnection(){}
    //寻找客户
    public Object findCustomer(){}
    //创建产品
    public Object createproduct(){}
    //展示产品
    public void displayproduct(){}
}
```

现在要你用单一职责原则来重构这一段代码

来看看这段代码的问题：Customer类承担了太多职责，它既有连接数据库的方法，也有寻找客户的方法，如果其他的类中也有需要这些方法的时候，则代码难以重用。因此可以对这个类进行拆分，来满足单一职责原则。可以将这个类拆成3个类，DButil用于连接数据库，CustomerDAO用于findCustomer，Product用于创建和展示产品

```java
public class DBUtil {
    public void getConnection() {
        // 连接数据库的代码
    }
}

public class CustomerDAO {
    private DBUtil dbUtil;

    public CustomerDAO(DBUtil dbUtil) {
        this.dbUtil = dbUtil;
    }

    public Object findCustomer() {
        dbUtil.getConnection();
        // 客户查找的代码
        return null;
    }
}

public class Product {
    public Object createProduct() {
        // 创建产品的代码
        return null;
    }

    public void displayProduct() {
        // 展示产品的代码
    }
}

public class Customer {
    private DBUtil dbUtil;
    private CustomerDAO customerDAO;
    private Product product;

    public Customer(DBUtil dbUtil, CustomerDAO customerDAO, Product product) {
        this.dbUtil = dbUtil;
        this.customerDAO = customerDAO;
        this.product = product;
    }

    public void connectToDB() {
        dbUtil.getConnection();
    }

    public Object findCustomer() {
        return customerDAO.findCustomer();
    }

    public Object createProduct() {
        return product.createProduct();
    }

    public void displayProduct() {
        product.displayProduct();
    }
}
```

这样重构之后，每个类都有自己的作用，Customer现在依赖DBUtil，Product，CustomerDAO，需要时通过构造函数注入，这种设计方式代码复用性强，如果还有别的类需要这样的功能，就直接调方法就可以了

### 开闭原则

开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

先来看一段代码

```java
public class ChartDisplay {
    public void display(String type) {
        if (type.equals("pie")) {
            PieChart chart = new PieChart();
            chart.display();
        } else if (type.equals("bar")) {
            BarChart chart = new BarChart();
            chart.display();
        }
    }
}

public class PieChart {
    public void display() {
        // 显示饼状图的代码
    }
}

public class BarChart {
    public void display() {
        // 显示柱状图的代码
    }
}
```

可以看出display这个方法是判断传进来的字符串是什么类型，再来创建折线图对象。这样的设计方式弊端很大：如果新增加了一个类LineChart，那么这段代码的display部分就必须修改逻辑，这就违法了开闭原则。现在对这段代码进行重构

```java
public abstract class AbstractChart {
    public abstract void display();
}

public class ChartDisplay {
    private AbstractChart chart;
    public void setChart(AbstractChart chart) {
        this.chart = chart;
    }

    public void display() {
        chart.display();
    }
}

public class PieChart extends AbstractChart {
    public void display() {
        // 显示饼状图的代码
    }
}

public class BarChart extends AbstractChart {
    public void display() {
        // 显示柱状图的代码
    }
}

// 新增的折线图类
public class LineChart extends AbstractChart {
    public void display() {
        // 显示折线图的代码
    }
}
```

不难看出，这会用到里式代换原则，先将图表抽象成一个类，再定义抽象方法display。

这样，如果需要增加一种新的图表，如折线图 `LineChart`，只需将 `LineChart` 作为 `AbstractChart` 的子类，然后在客户端向 `ChartDisplay` 中注入一个 `LineChart` 对象即可，无需修改现有类库的源代码。这符合开闭原则，对扩展是开放的，对修改是封闭的。

### 里式代换原则

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。

> 我个人认为学了javaSE中的多态这点可以自行理解

### 依赖倒转原则

**依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。**

学了Spring的这个也能秒懂的

依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，**尽量引用层次高的抽象层类，即使用接口和抽象类**进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。说通俗点就是针对抽象层来编程，将具体类的对象通过**依赖注入(DependencyInjection, DI)**的方式注入到其他对象中

示例代码

```java
// 抽象电梯接口
public interface Elevator {
    void moveUp();
    void moveDown();
}

// 电梯控制器类，依赖抽象电梯接口
public class ElevatorController {
    private Elevator elevator;

    public ElevatorController(Elevator elevator) {
        this.elevator = elevator;
    }

    public void goUp() {
        elevator.moveUp();
    }

    public void goDown() {
        elevator.moveDown();
    }
}

// 实现了抽象电梯接口的具体电梯类
public class SimpleElevator implements Elevator {
    public void moveUp() {
        System.out.println("SimpleElevator: Moving up");
    }

    public void moveDown() {
        System.out.println("SimpleElevator: Moving down");
    }
}

// 高级电梯类，也实现了抽象电梯接口
public class AdvancedElevator implements Elevator {
    public void moveUp() {
        System.out.println("AdvancedElevator: Moving up");
    }

    public void moveDown() {
        System.out.println("AdvancedElevator: Moving down");
    }
}
```

这里我们针对抽象层编程体现在 `private Elevator e;`,再通过构造方法将传入的对象注入进这个e中，会发现，这里又体现了里氏代换原则。在示例中，我们有一个 `SimpleElevator` 类和一个 `AdvancedElevator` 类，它们都实现了抽象电梯接口 `Elevator`。通过在电梯控制器类的构造函数中传入相应的具体电梯对象，我们就可以使用不同类型的电梯，而无需修改电梯控制器的源代码。这样，我们符合了依赖倒转原则，高层模块（`ElevatorController`）依赖于抽象（`Elevator`）而非具体实现，达到了解耦和灵活性的目的。

### 合成复用原则

**合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的**，是这样的，继承会导致子类父类紧密耦合，如果要修改父类的代码，子类也会收到影响，又会引发一系列问题，相比之下，组合提供了更灵活的方式来构建对象间的关系。

假设你有一个车Car，他有轮子(Wheel),有发动机(Engin),有车壳(kezi),用合成复用原则设计这辆车

代码示例

```java
public interface Component {
    String getDescription();
}
public class Engine implements Component {
    @Override
    public String getDescription() {
        return "Engine component";

    }
}
public class Wheel implements Component {
    @Override
    public String getDescription() {
        return "Wheel component";
    }
}
public class kezi implements Component {
    @Override
    public String getDescription() {
        return "kezi component";
    }
}
public class Car {
    private Component engine;
    private Component wheel;
    private Component steeringWheel;

    public Car() {
        engine = new Engine();
        wheel = new Wheel();
        steeringWheel = new SteeringWheel();
    }

    public String getDescription() {
        StringBuilder sb = new StringBuilder();
        sb.append("Car consists of:\n");
        sb.append(engine.getDescription()).append("\n");
        sb.append(wheel.getDescription()).append("\n");
        sb.append(steeringWheel.getDescription()).append("\n");
        return sb.toString();
    }
}
```

测试类

```java
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        String description = car.getDescription();
        System.out.println(description);
    }
}
```

> 通过组合关系，我们可以将若干个对象组合在一起，形成一个新的对象，从而实现代码灵活性

### 迪米特法则

暂略

### 接口隔离原则

暂略

<br>

# 初始-了解简单工厂模式

简单工厂模式并不在23种设计模式的范畴种，但是一个经常用的到，入门必学的模式。

案例：用java开发一套图表库，该图表库可以提供各种不同外观的图表，例如柱状图、饼状图、折线图等。希望能开发出一套灵活的图表库，而且可以扩展，以便之后加入一些新类型的图表

初始化方案：

```java
class Chart {
    private String type; //图表类型

    public Chart(Object[][] data, String type) {
        this.type = type;
        if (type.equalsIgnoreCase("histogram")) {
            //初始化柱状图
        }
        else if (type.equalsIgnoreCase("pie")) {
            //初始化饼状图
        }
        else if (type.equalsIgnoreCase("line")) {
            //初始化折线图
        }
    }

    public void display() {
        if (this.type.equalsIgnoreCase("histogram")) {
            //显示柱状图
        }
        else if (this.type.equalsIgnoreCase("pie")) {
            //显示饼状图
        }
        else if (this.type.equalsIgnoreCase("line")) {
            //显示折线图
        }    
    }
}
```

这个方案缺点有很多

1. Chart类的职责过重，它不仅要初始化，还要展示图表，这违法了**单一职责原则**，不利于类的重用和维护

2. 当新添加一个图表时，必须得修改Chart类的源代码，违反了**开闭原则**

3. 客户端只能通过new来直接创建Chart对象，Chart类于客户端类**耦合度高，对象的创建和使用无法分离**

如果用简单工厂模式，那就可以解决这一问题。

简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建图表对象，而在引入工厂类之后，客户端可以直接通过工厂类来创建对象。工厂类提供了一个静态方法供客户端使用，根据所传入的参数不同可以创建不同的图表对象。

这里我们先写一个Chart接口将图表抽象

```java
interface Chart{
    public void display();
}
//柱状图
class HistogramChart implements Chart{
    //实现display
}
class PieChart implements Chart{
    //实现display
}
class LineChart implements Chart{
    //实现display
}

//创建工厂类
class ChartFactory{
    //静态方法
    public static Chart getChart(String type){
        Chart chart = null;
        if (type.equalsIgnoreCase("histogram")){
            chart = new HistogramChart();
        } else if (type.equalsIgnoreCase("PieChart"){
            chart = new PieChart();
        } else if type.equalsIgnoreCase("LineChart"){
            chart = new LineChart();
        }
        return chart;
    }
}
```

这样在客户端要获取代码的时候就可以不用new了，耦合度就降低了

```java
class Main{
    public static void main(String []args){
         Chart chart = ChartFactory.getChart("histogram");   
         chart.display();    
    }
}
```

*用xml文件，可以实现ChartFactory.getChart("config.xml"),如果需要更换图表，甚至客户端代码都不需要改，符合"开闭原则"

总结：

> 简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建与使用分离开。
> 
> 主要优点：
> 
> 1. 客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离
> 
> 2. 引入配置文件，可以不修改客户端代码的情况下更换或增加新的产品类。
> 
> 缺点：
> 
> 1. 工厂类的职责过重，一旦停止工作，整个系统收到影响
> 
> 2. 系统扩展困难，一旦添加新的产品类，那工厂的逻辑就得再次修改
> 
> 3. 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

# 工厂方法模式

工厂方法模式是简单工厂模式的大哥。先来说说简单工厂模式的缺点，它将所有产品创建的职责都集中在了Factory中，导致各种产品类与这个Factory紧密耦合。而且如果要增加新的产品，那么必须得改动Factory中的源代码，而且大量的if-else影响系统的效率。

工厂方法模式就能很好的解决这也问题，在工厂方法模式中，我们**不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构**

定义：**工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。**

案例：当你购买电脑时，需要选择不同品牌和型号的计算机。在这种情况下，工厂方法模式可以很好地应用。

```java
//定义一个抽象的电脑类，包含抽象方法compute计算
public abstract class computer{
    public abstract void compute();
}


//定义具体的产品类继承Computer
public class LenovoComputer extends Computer {
    @Override
    public void compute() {
        System.out.println("使用联想电脑进行计算");
    }
}

public class DellComputer extends Computer {
    @Override
    public void compute() {
        System.out.println("使用戴尔电脑进行计算");
    }
}


//定义一个抽象的电脑工厂，并包含一个抽象的工厂方法createComputer()\
public abstract class ComputerFactory {
    public abstract Computer createComputer();
}


//继续创建电脑的工厂LenovoFactory和DellFactory,它们都是ComputerFactory子类
public class LenovoFactory extends ComputerFactory {
    @Override
    public Computer createComputer() {
        return new LenovoComputer();
    }
}
public class DellFactory extends ComputerFactory {
    @Override
    public Computer createComputer() {
        return new DellComputer();
    }
}


//客户端测试
public class Client {
    public static void main(String[] args) {
        // 创建联想电脑
        ComputerFactory lenovoFactory = new LenovoFactory();
        Computer lenovoComputer = lenovoFactory.createComputer();
        lenovoComputer.compute(); // 输出：使用联想电脑进行计算

        // 创建戴尔电脑
        ComputerFactory dellFactory = new DellFactory();
        Computer dellComputer = dellFactory.createComputer();
        dellComputer.compute(); // 输出：使用戴尔电脑进行计算
    }
}
```

可以品到，简单工厂模式只是对产品进行抽象层编程，而工厂方法模式还对工厂进行抽象层编程，通过工厂方法模式，我们可以通过具体的工厂类来创建不同品牌的电脑对象，而不需要直接实例化具体的产品类。这样使得客户端代码与具体产品类解耦，也方便了后续的扩展和维护。

优点：

> 1. 工厂方法用来创建客户所需的产品，隐藏了具体产品类的实例化细节。
> 
> 2. 工厂角色和产品角色之间通过多态性设计实现解耦。
> 
> 3. 添加新产品时，无需修改抽象工厂和抽象产品接口，只需添加具体工厂和具体产品

缺点：

> 1. 添加新产品时，还要提供与之对应的工厂类，系统中类的个数将会成对增加
> 
> 2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度

# 抽象工厂模式

工厂方法模式解决了简单工厂模式的工程类的职责太重，与产品耦合等问题，但是一个工厂只会生成出一种产品，当产品越来越多的时候，工厂类也会变得越来越庞杂。此时，我们可以考虑将一些相关的产品组成一"产品族",这就是抽象工厂模式的基本思想】





```java
/*假设我们正在开发一个游戏，这个游戏包含不同类型的角色和装备。
我们知道，每个角色都需要穿戴不同类型的装备，例如法师需要穿戴魔法师服装和法杖，战士需要穿戴盔甲和武器等等。
但是每个角色的装备是不一样的，因此它们需要被指定为一组产品族*/
interface CharacterFactory {
    public Cloth createClothing();
    public Weapon createWeapon();
}

class MageFactory implements CharacterFactory {
    @Override
    public Cloth createClothing() {
        return new Cloth1();
    }
    @Override
    public Weapon createWeapon() {
        return new Weapon1();
    }
}
class WarriorFactory implements CharacterFactory {
    @Override
    public Cloth createClothing() {
        return new Cloth2();
    }
    @Override
    public Weapon createWeapon() {
        return new Weapon2();
    }
}
interface Cloth{
    public void display();
}
class Cloth1 implements Cloth{
    @Override
    public void display() {
        System.out.println("展示法师Cloth");
    }
}
class Cloth2 implements Cloth {
    @Override
    public void display() {
        System.out.println("展示法师Cloth");
    }
}
interface Weapon{
    public void display();
}
class Weapon1 implements Weapon{
    @Override
    public void display() {
        System.out.println("展示法师Weapon");
    }
}
class Weapon2 implements Weapon {
    @Override
    public void display() {
        System.out.println("展示战士Weapon");
    }
}
public class Main {
    public static void main(String[] args) {
        CharacterFactory m_characterFactory = new MageFactory();
        Cloth m_cl = m_characterFactory.createClothing();
        Weapon m_wea = m_characterFactory.createWeapon();
        m_cl.display();
        m_wea.display();

        CharacterFactory w_characterFactory = new WarriorFactory();
        Cloth w_cl = w_characterFactory.createClothing();
        Weapon w_wea = w_characterFactory.createWeapon();
        w_cl.display();
        w_wea.display();
    }
}
```

不难看出，如果使用工厂方法模式来构建这个类的话，会发现法师的Cloth、Weapon，战士的Cloth、Weapon这些类。得为它们建造两个抽象工厂abstractCloth、abstractWeapon，然后在此基础上，又得派生出具体的战士Cloth工厂、战士Weapon工厂，法师Cloth工厂、法师Weapon工厂，实在是太繁杂了。而在抽象工厂模式，将Cloth和Weapon看成一整个，然后再创建工厂的时候就将它们创建，当然都是针对抽象层编程。





这个模式我理解了好久，来做一道练习题：

假设你正在设计一个游戏，该游戏有多个种族的角色，包括人类（Human）、精灵（Elf）和兽人（Orc）。每个种族都有自己的武器（Weapon）和装备（Armor），例如人类使用剑和盾牌，精灵使用魔法棒和轻盔甲，兽人使用巨斧和重甲。使用抽象工厂模式设计一个类结构来创建不同种族的角色和其对应的武器和装备。利用抽象工厂模式构造这个类。



```java
//种族工厂
interface zhongzufactory {
    public zhongzu create();
}


//种族父类
interface zhongzu {
    public Weapon createWeapon();
    public Armor createArmor();
}

//人类工厂
class HumanFactory implements zhongzufactory {
    @Override
    public zhongzu create() {
        return new Human();
    }
}
//法师工厂
class ElfFactory implements zhongzufactory {

    @Override
    public zhongzu create() {
        return new Elf();
    }
}

//兽人工厂
class  OrcFactory implements  zhongzufactory{

    @Override
    public zhongzu create() {
        return new Orc();
    }
}

//人 -> 实现种族接口
class  Human implements zhongzu {
    @Override
    public Weapon createWeapon() {
        return new jian();
    }
    @Override
    public Armor createArmor() {
        return new dun();
    }
}

//法师 -> 实现种族接口
class Elf implements zhongzu {
    @Override
    public Weapon createWeapon() {
        return new mofaban();
    }
    @Override
    public Armor createArmor() {
        return new qingkuijia();
    }
}

//兽人 -> 实现种族接口
class Orc implements  zhongzu{
    @Override
    public Weapon createWeapon() {
        return new jufu() ;
    }
    @Override
    public Armor createArmor() {
        return new zhongjia();
    }
}


//武器接口
interface Weapon {
    public void display();
}

//装备接口
interface Armor {
    public void display();
}

//剑
class jian implements Weapon {
    @Override
    public void display() {
        System.out.println("人展示🗡");
    }
}
//盾
class dun implements Armor {
    @Override
    public void display() {
        System.out.println("人展示盾");
    }
}
//魔法棒
class mofaban implements Weapon {
    @Override
    public void display() {
        System.out.println("法师展示魔法棒");
    }
}
//轻盔甲
class  qingkuijia implements Armor {
    @Override
    public void display() {
        System.out.println("法师展示轻盔甲");
    }
}
//巨斧
class jufu implements Weapon {
    @Override
    public void display() {
        System.out.println("兽人展示巨斧");
    }
}
//重甲
class zhongjia implements Armor {

    @Override
    public void display() {
        System.out.println("兽人展示重甲");
    }
}
```



客户端

```java
public class Main {
    public static void main(String[] args) {
        //抽象层编程
        zhongzufactory humanfactory = new HumanFactory();
        zhongzu human = (Human) humanfactory.create();
        Weapon huamn_weapon = human.createWeapon();
        huamn_weapon.display();
        Armor huamn_armor = human.createArmor();
        huamn_armor.display();

        zhongzufactory Elffactory = new ElfFactory();
        zhongzu Elf = Elffactory.create();
        Armor ELf_armor = Elf.createArmor();
        ELf_armor.display();
        Weapon Elf_weapon = Elf.createWeapon();
        Elf_weapon.display();

        zhongzufactory Orcfactory = new OrcFactory();
        zhongzu Orc =  Orcfactory.create();
        Armor Orc_armor = Orc.createArmor();
        Orc_armor.display();
        Weapon Orc_weapon = Orc.createWeapon();
        Orc_weapon.display();
    }
}
```

输出结果

    人展示🗡
    人展示盾
    法师展示轻盔甲
    法师展示魔法棒
    兽人展示重甲
    兽人展示巨斧

如果你写完之后，又有要求得为种族再增加一个属性————金钱，每个种族的初始金钱不同。

那此时就不需要再修改了源代码了，只需要在zhongzu接口里增加一个初始化金钱的方法就可以了，然后写一个Money接口，再使各个种族的moeny实现接口。



总结：抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用抽象工厂模式的主要优点包括**隔离了具体类的生成、能够保证客户端只使用同一产品族中的对象、增加新的产品族方便等。在设计上符合开闭原则，能够提高系统的灵活性、可扩展性和可维护性**。但是它也存在缺点，主要是**增加新的产品等级结构时，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背了开闭原则**

****



感谢大佬的教程，带我学习设计模式

[史上最全设计模式导学目录（完整版）_史上最全设计模式lovelion-CSDN博客](https://blog.csdn.net/LoveLion/article/details/17517213?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169743190816800222875841%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169743190816800222875841&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-17517213-null-null.142^v96^pc_search_result_base2&utm_term=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)

---
title: 求组合数的各种方法
excerpt: 组合数
tags: 求组和数
categories: 算法学习
quicklink: true
date: 2023-10-20 22:55:49

---

# 1.用杨辉三角求组合数

需求：有q(q <= 10000) 组询问，每组询问两个整数n，m (1 <= m <= n <= 2000)，求$C_{n}^{m}$mod(10$^9$ + 7)

这是求组合数的第一种方法，也是最简单，最好理解的一种，这种方法适合m，n较小的时候使用

递推过程：

$C_{n}^{m}$  = $C_{n-1}^{m}$ + $C_{n-1}^{m-1}$ ,这个公式高中应该都学过。于是就可以用这个式子递推出所有组合数

```java
//先开好了一个数组
int C[2000][2000];
int mod = 1e9 + 7;
void getC(){
    for(int i=0; i<N; i++)
        for(int j=0; j<=i; j++)
            if(j==0) C[i][j] = 1;
            else C[i][j] = (C[i-1][j] + C[i-1][j-1])%mod;
}
```

这样就写好了，写完发现这不是杨辉三角嘛，就是了。将杨辉三角按行列排好序，就能对应组合数的关系

# 2.利用费马小定理，递推，乘法逆元，快速幂一起求解组合数

还是上一题的基础上n，m的取值范围扩大到了1e5

1. 先来了解一下乘法逆元并快速上手。（~~证明不会哈哈啊哈~~）
   
   (a + b) % p = (a % p + b % p) % p  这是对的 ✅
   
   (a - b) % p = (a % p - b % p) % p  这是对的 ✅
   
   (a * b) % p = (a % p * b % p) % p  这是对的 ✅
   
   (a / p) % p = (a % p / b % p) % p  <span style="color:red;">这是错的</span> ❌
   
   那有没有办法可以解决这种情况，有。我们先来看一个式子，a / b = a * (1/b), 
   
   这里我们将除法转换成了乘法(b!=0)，那针对以上情况我们也可以找到一个数 x，能使除以p这一步变成乘 x（至于怎么找，看别的文章），将式子转换成 (a * x) % p,之后套用第三个式子即可。

2. 费马小定理（证明老难看懂了，自己看，直接说结论）
   
   $a * a^{p-2}$ ≡ 1 (mod) p
   
   这说明了a在mod p的意义下的乘法逆元是$a^{p-2}$ 

3. 快速幂，适用于快速求得$a^b$ ，直接上代码

```cpp
ll qpow(ll a, ll b){
    ll res = 1;
    while(b){
        if(b&1) res = res * a  %p;
        a = a * a % p;
        b >>= 1;
    }
    return res;    
}
```

推导过程(记住最好)

$C_n^m = C_{n-1}^m + C_{n-1}^{m-1}$ 递推话会TLE，毋庸置疑。

那就考虑用 $C_n^m = \frac{n!}{(n-m)!m!}$ 这个公式。开两个数组分别存mod p意义下的<mark>阶乘</mark>和<mark>阶乘的逆元</mark>

用f[x]存  $x!\quad( mod\quad p)$ 的值

用g[x]存 $(x!)^{-1}\quad(mod\quad p)$ 的值，注意这里的 -1次方是代表 $x!$的乘法逆元

如果存完之后，那么想要求得组合数就简单多了，直接照搬$\frac{n!}{(n-m)!m!}$下来就可以了

比如$C_n^m(mod\quad p)=f[n] *g[n-m]*g[m]\quad (mod\quad p)$ ，这很好理解啊，我想获得你这个组合数得只，只需要知道 $n!$ ， 以及$(n-m)!$ 模p意义下的乘法逆元，和$m!$模p意义下的乘法逆元，再将它们都相乘，就是结果了。

实现代码 

```cpp
void init(){
    f[0] = g[0] = 1;
    //N是1e5
    for(int i=1; i<=N; i++){
        f[i] = f[i-1]*i%p;
        g[i] = g[i-1]*qpow(i,p-2)%p;
    }
}
ll getC(ll n, ll m){
    return f[n]*g[n-m]%p*g[m]%p;
}
```

其中有关g[i]的递推的证明过程,用了费马小定理

$\frac{1}{i!}\quad (mod\quad p)= \frac{1}{i}*\frac{1}{(i-1)!}\quad (mod\quad p) = qpow(i,p-2)$

无非就是对i的阶乘求乘法逆元，可以用上之前求出来的(i-1)的阶乘的乘法逆元和单独对i求乘法逆元，而这一步也用上了费马小定理。

# 3.卢卡斯定理求组合数

以上都是m、n比较小的情况，如果 1 <= m <=n  <= 1e18 的话，那该怎么办，卢卡斯定理就适用于大组合数的情况

卢卡斯定理:

> $C_n^m ≡ C_{n/p}^{m/p}*C_{n模p}^{m模p}\quad (mod\quad p)$

n模p和模p一定是小于p的数，可以用上一个方法求解，而$C_{n/p}^{m/p}$ 可以继续用卢卡斯定理递归求解，边界条件：当m=0，返回1

```cpp
LL getC(int n, int m, int p){
    return f[n]*g[n-m]%p*g[m]%p;
}
int lucas(LL n, LL m, int p){
    if(m==0)return 1;
    return lucas(n/p,m/p,p) * getC(n%p,m%p,p)%p;
}
```

这样求大的组合数的时候也不慌了

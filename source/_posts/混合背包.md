---
title: 混合背包
excerpt: 混合背包呦呦呦
tags: dp
categories: 背包系列
quicklink: true
date: 2023-11-29 09:16:00

---

# 混合背包

混合背包就结合了之前学的三种背包，代码拼接就完事了

## 题目

有n种物品和一个容量是m的背包。物品一共有三类

- 第一类物品只能用1次 （01背包）

- 第二类物品可以用无限次 （完全背包）

- 第三类物品最多只能用$s_i$次 （多重背包）

每种体积是$v_i$，价值是$c_i$，求解将哪些物品装入背包，可以使物品体积总和不超过背包容量，且价值总和最大。输出最大价值

## 输入

第一两个整数n,m，分别表示物品种数和背包容量。接下来有n行，每行三个整数$v_i,c_i,s_i$,分别表示第$i$种物品的体积、价值和数量

- $s_i=-1$表示第$i$种物品只能用1次

- $s_i=0$表示第$i$种物品可以用无限次

- $s_i>0$表示第$i$种物品可以使用$s_i$次

eg: 4 5

    1 2 -1

    2 4 1

    3 4 0

    4 5 2

 输出 8，8是最大价值

## 思路及代码

可以分类处理:

- 利用多重背包的二进制优化，将多重背包转换为多个01背包。用x,y,z三个数组来记录转换之后的<mark>所有</mark>背包的体积、价值、类型，c[i]==0表示完全背包，q[i]==1表示01背包

- 最后以c的值分类，做完全背包和01背包

代码

```cpp
int num=1;
for(int i=1;i<=n;i++){
    //v是体积，c是价值，s是类型
    cin >> v >> c >> s;
    if(s==0){
        //完全背包
        x[num] = v;
        y[num] = c;
        z[num++] = 0; //给这个背包确定类型
    } else{
        if(s==-1){
            //是01背包，那就把它转换成多重背包
            s=1;
        }
        //多重背包二进制拆分
        for(int j=1;j<=s;j<<=1){
            x[num] = v*j;
            y[num] = c*j;
            z[num++] = 1; //确定类型 
            s -= j;
        }
        if(s){
            x[num] = s*v;
            y[num] = s*c;
            z[num++] = 1;
        }        
    }
}
```

以上步骤将所有的背包分为了两类，接下来分别处理就可以了

```cpp
for(int i=1;i<num;i++){
    if(c[i]==1){
        //01背包->倒着遍历
        for(int j=m;j>=x[i];j--){
            f[j]=max(f[j],f[j-x[i]]+y[i]);
        }
    }else{
        //完全背包->正着遍历
        for(int j=x[i];j<=m;j++){
            f[j]=max(f[j],f[j-x[i]]+y[i]);
        }
    }
}
cout << f[m] << endl;
```



以上就是混合背包的基本思路了

---
title: 树形dp P2016 战略游戏
excerpt: 无
tags: 
categories: 树形dp系列
quicklink: true
date: 2024-3-28 23:16:00

---

# 战略游戏

## 题目背景

Bob 喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。

## 题目描述

他要建立一个古城堡，城堡中的路形成一棵无根树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能瞭望到所有的路。

注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被瞭望到。

请你编一程序，给定一树，帮 Bob 计算出他需要放置最少的士兵。

## 输入格式

第一行一个整数 $n$，表示树中结点的数目。

第二行至第 $n+1$ 行，每行描述每个结点信息，依次为：一个整数 $i$，代表该结点标号，一个自然数 $k$，代表后面有 $k$ 条无向边与结点 $i$ 相连。接下来 $k$ 个整数，分别是每条边的另一个结点标号 $r_1,r_2,\cdots,r_k$，表示 $i$ 与这些点间各有一条无向边相连。

对于一个 $n$ 个结点的树，结点标号在 $0$ 到 $n-1$ 之间，在输入数据中每条边只出现一次。保证输入是一棵树。

## 输出格式

输出文件仅包含一个整数，为所求的最少的士兵数目。

## 样例 #1

### 样例输入 #1

```
4
0 1 1
1 2 2 3
2 0
3 0
```

### 样例输出 #1

```
1
```

## 提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 1500$。

# 思路

很明显的一道树形dp的题目，先这颗树建好。对于每一个结点，我们都有选择放士兵或不放士兵，由此可以定义出 

$f[u][0]$ 代表以第u个结点为子树不选择放士兵时的最少士兵数

$f[u][1]$ 代表以第u个结点为子树选择放士兵时的最少士兵数

如果这个结点不放士兵，那么它的所有子节点都必须放士兵，否则就看不到这个结点，则有$f[u][0]=\sum f[v][1]$

如果这个结点放士兵，那么它的子节点放不放士兵都无所谓了，于是就选择最优的情况就可以了 $f[u][1]=\sum max(f[v][0],f[v][1])$

于是可以写出优雅的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,k,t,f[1505][2];
vector<int>e[1505];

void dfs(int u,int fa){
    f[u][1] = 1; f[u][0] = 0;
    for(int v:e[u]){
        if(fa!=v){
            dfs(v,u);
            f[u][0] += f[v][1];
            f[u][1] += min(f[v][1],f[v][0]);
        }
    }
}

int main(){
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> a >> k;
        while(k--){
            cin >> t;
            e[a].push_back(t);
            e[t].push_back(a);
        }    
    }
    dfs(0,-1);
    cout << min(f[0][0],f[0][1]);
    return 0;


}
```

太优雅了，树形dp😵😵😵😵😵😵

---
title: 状压dp 小国王
excerpt: 无
tags: dp
categories: 状压dp系列
quicklink: true
date: 2023-12-5 09:16:00

---

# 小国王

状压dp好难得嘞，理解好久才能缓过来，先看看题目

## 题目

在n*n得棋盘上放k个国王，国王可以攻击相邻得8个格子，求使他们无法互相攻击得方案总数

比如n=3,k=2。一共用16种方案，自己数数

## 思路

这怎么做？这怎么做？这怎么做？反正我知道一定是动态规划，但是有这个"国王格子周围8格子不能放国王"这个限制条件，我就不知道怎么写状态转移方程了

我们先考虑一行中，我们怎么样知道这个状态合不合法，假设有国王得地方是1，比如在3*3的棋盘中的一行:

- 0 0 1 合法

- 0 1 0 合法

- 0 1 1 不合法

- 1 0 0 合法

- 1 0 1 合法

- 1 1 0 不合法

- 1 1 1 不合法

<mark>发现可以用二进制来表示一行中的状态是否合法，然后我们再用十进制数来存储，这就是状态压缩</mark>

比如，在上面的例子中，十进制数 1 2 4 5 是合法的，可以放入棋盘一行的方案。

那我们要如何用代码实现这个过程呢？先上代码

```cpp
for(int i=0;i<(1<<n);i++){
    //筛出了合法方案
    if(!(i&i>>1)){

    }
}
```

对，就是 `!(i&i<<1)`，来判断是否合法，原理是什么,这个式子是先执行`i<<1`，这里将一个数左移一位。如果i是3(二进制011),左移一位就变成了110，再与011&运算，如果这个二进制数是含有相邻的1的话，那这个整个操作就会是1，如果不含相邻的1话，那就会是0，以此来判断是否合法。

<br>

判一行合法之后，我们还要判断行与行之间是否兼容。这里也用位运算,先假设 a是一个合法方案，b是一个合法方案，现在我们要求出他们如果是行邻居的话，合不合法

```cpp
if(!(a&b)&&!(a&(b>>1))&&!(a&(b<<1))){
    //这两种方案当邻居合法
}
```

- 首先 `!(a&b)` 是要判断这两行是否有在同一列的1，比如1（001）和 5(101)，明显有一列是都有1的，这就不合法了

- `!(a&(b>>1))`是要判断这两行里每一个国王左上是否有国王，比如b=2（010）和a=1（001），b在上面，a在下面，第2行里的1在第二行的1左上方，执行这步操作，将b右移一位，结果就是1，这不合法

- `!(a&(b<<1)`就是判断右上了，与上面无异

那我们就已经有了办法可以用很快的办法得到状态是否可行，接下来就用动态规划将这题推出来了

## 状态定义

设f[i][j][a] 代表在前i行里，放了j个国王，第a个状态时的方案数

$f[i][j][a]=\sum f[i-1][j-c[a]][b]$

这里c[a]是代表这个状态的国王数量，这里很像前面的多重背包的思想，最后递推出$f[n][k][a]$的时候，总方案数就是$ans=\sum f[n][k][i]$

给出代码了

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,cnt;
int s[1<<12],num[1<<12];
long long f[12][144][1<<12]; 

int main(){
    cin >> n >> k;
    //预处理出所有的合法方案
    for(int i=0;i<(1<<n);i++){
        if(!(i&i>>1)){
            //是合法的
            s[cnt++]=i;
            //处理该方案有多少个国王 
            for(int j=0;j<n;j++){
                num[i]+=(i>>j&1);
            } 
        }
    } 
    f[0][0][0]=1;
    //f[i][j][a]代表前i行，j个国王，状态为a时候的方案数
    for(int i=1;i<=n;i++){
        for(int j=0;j<=k;j++){
            //枚举所有方案数的组合 
            for(int a=0;a<cnt;a++){
                for(int b=0;b<cnt;b++){
                    //判断该组合行内是否兼容
                    int c = num[s[a]];
                    if(j>=c&&!(s[a]&s[b])&&!(s[a]&(s[b]>>1))&&!(s[a]&(s[b]<<1)))
                    f[i][j][a]+=f[i-1][j-c][b]; 
                }
            }
        }
    }
    int ans;
    for(int i=0;i<cnt;i++) ans+=f[n][k][i];
    cout << ans; 
} 
```

这里有一个小技巧

可以直接循环到n+1，如何直接输出 f[n+1][k][0]就可以了。

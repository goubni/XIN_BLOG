---
title: 股票问题
excerpt: 无
tags: dp
categories: 线性dp系列
quicklink: true
date: 2023-12-4 09:16:00

---

# 线性dp 股票买卖

## 题目

给定一个长度为N的数组，数组中的第i个数字表示一个给定股票在第i天的价格，设计一个算法来计算你所能获得的最大利润，你可以尽可能完成多笔交易，你不能同时参与多笔交易，必须在购买之前售出之前的股票

比如 7 1 5 3 4 6，在第二天买入第三天卖出，第四天买入第六天卖出，一共赚了7.可以证明这是最大的

## 思路

我们采取分类转移的办法做，可以发现，对于每一天，就只能有两种状态，一种是手中有票，一种是手中无票，我们设$f[i][0]$代表这一天手中没有票时的最大利润，$f[i][1]$代表这一天手中有票时的最大利润

我们像思考打家劫舍一样来得出这题的转移过程.

于是可以得出状态转移方程

- $f[i][0]=max(f[i-1][0],f[i-1][1]+w[i])$

- $f[i][1]=max(f[i-1][0]-w[i],f[i-1][1])$

边界初始化:

- f[1][0] = 0 代表手中没有股票，利润是0

- f[1][1] = -w[1] 代表手中有股票，利润是-w[i]

给出代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,w[1001],f[1001][2];
int main(){
    cin >> n;
    for(int i=1;i<=n;i++)cin>>w[i];
    f[1][0]=0;f[1][1]=-w[1];
    for(int i=2;i<=n;i++){
        f[i][0]=max(f[i-1][0],f[i-1][1]+w[i]);
        f[i][1]=max(f[i-1][0]-w[i],f[i-1][1]);
    }
    cout << max(f[n][0],f[n][1]);
    return 0;
} 
```

# 股票买卖k笔交易

这题大致上以上一个股票买卖相同，不过这里限定了，你最多可以完成k笔交易。此时求出最大利润

## 思路

 上面的是考虑了前i天手中是否有股票，现在还得考虑不能超过k比交易

状态表示:

$f[i][j][0]$表示前$i$天买卖了$j$次，当前手中无票，能获取的最大利润

$f[i][j][1]$表示前$i$天买卖了$j$次，当前手中有票，能获取的最大利润

- 先想想当前手中无票$f[i][j][0]$会由什么转移过来，可以从前面无票（一直不买）$f[i-1][j][0]$，前面有票（现在卖掉）$f[i-1][j][1]+w[i]$两种转移过来，

- 那当前手中有票$f[i][j][1]$可以由前面无票(现在买入)$f[i-1][j-1][0]-w[i]$，因为买入会增加交易次数，则是从前面j-1次状态转移过来；可以从前面有票(一直没卖)$f[i-1][j][1]$转移过来

综上所述，得出状态转移

- $f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i])$

- $f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0]-w[i])$

最恶心的一步来了，就是初始化

这里可以用一个技巧，涉及到求最大，状态不合法就置为负无穷

比如 f[0][j][0]代表前0天的买卖j次手中无票，那明显是0

而f[0][j][1]代表前0天的买卖j次手中有票，那不合法，前0天你手中怎么能有票呢？那就置为负无穷

于是可以得出代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,w[1001],f[1001][1001][2];
int main(){
    cin >> n >> k;
    for(int i=1;i<=n;i++)cin>>w[i];

       for(int i=0;j<=k;j++) f[0][j][1]=-1e6;

       for(int i=1;i<=n;i++){
           for(int j=k;j<=k;j++){
            f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i]);
            f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0]-w[i]);
        }
    }
       cout << f[n][k][0];
    return 0;
} 
```

这里可以压缩一维，把i那一维去掉也不影响结果

# 股票买卖含冷冻期

与最上面的股票买卖类似，不过加了个限制，就是卖出股票之后，你无法在第二天买入股票(即冷冻期为1天)

## 思路

最大利润f是天数i的函数，每天有两个状态：手中有票或手中无票。无票可以分为无票的第一天，无票的第二天(冷冻期)及以后。

- $f[i][0]$表示第i天手中无票的第一天，能获得的最大利润

- $f[i][1]$表示第i天手中有票，能获得的最大利润

- $f[i][2]$表示第i天是手中无票的第2天之后，能获得的最大利润

这个带权有向图自己画

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,w[1001],f[1001][3];
int main(){
    cin >> n >> k;
    for(int i=1;i<=n;i++)cin>>w[i];

       f[0][1]=-1e7;f[0][0]=-1e7;f[0][2]=0;

       for(int i=1;i<=n;i++){
           f[i][1]=max(f[i-1][1],f[i-1][2]-w[i]);
           f[i][0]=f[i-1][1]+w[i];
           f[i][2]=max(f[i-1][0],f[i-1][2]);
    }
       cout << max(f[n][0],f[n][2]);
    return 0;
} 
```

> 这个就是股票买卖的三种题型，其实只要能画出那个带权有向图，初始化注意一下就好写了，主要是带权有向图得会话，记住分类转移。

---
title: 状压dp 玉米田
excerpt: 无
tags: dp
categories: 状压dp系列
quicklink: true
date: 2023-12-5 23:16:00

---

# 玉米田

农夫约翰的土地由 M×N 个小方格组成，现在他要在土地里种植玉米。非常遗憾，<mark>部分土地是不育的，无法种植</mark>。而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。现在给定土地的大小，请你求出共有多少种种植方法。土地上什么都不种也算一种方法。

#### 输入格式

第 1 行包含两个整数 M 和 N。

第 2..M+1 行：每行包含 N 个整数 0 或 1，用来描述整个土地的状况，1 表示该块土地肥沃，0 表示该块土地不育。

输出结果对1e8取模

## 思路

和小国王的思路是一样的

- 行内合法：用二进制数来代表一行内的所有状态,比如N=3的时候，每一行有这些个状态:000,001,010,011,100,101,110,111。其中相邻有1连在一起的是不合法的状态。即每行合法状态: 000,001,010,100,101。我们用 `!(i&i>>1)`来判断这个状态是否合法，在小国王里有讲。

- 行间兼容：要保证这两行不能有一列1存在，那就是`!(a&b)`，这个简单，但是这一题和小国王不同的是，题目有限制部分土地不育。这里开一个数组g,g中存了整张地图的信息，比如第一行地图是`1 0 0`，那 `g[0]=4`，这里也用到了状态压缩的思想，用二进制表示数据，十进制存储数据，这样我们的g存了整张地图的信息，此时要判断第i行是否可以种玉米，就`(a&g[i])==a`，细品，如果为真,则可以种。总结下来，要判断行内是否兼容：`!(a&b)&&(a&g[i])==a`

- 状态表示，设f[i][a]代表已经种植前i行，第i行第a个状态时的方案数

- 状态计算：$f[i][a]=\sum f[i-1][b]$

给出代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int Mod=1e9;
int n,m,cnt;
int g[14]; //存储整张地图的信息 
int s[1<<14];//合法状态的合集
int f[14][1<<14]; //前i行的第a个状态的方案数 

int main(){
    cin >> n >> m;
    //预处理出整张地图的信息和所有的合法状态 
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int x; cin >> x;
            //逆天技巧，及其惊艳 
            g[i]=(g[i]<<1)+x;
        }
    }
    //类似小国王 
    for(int i=0;i<(1<<m);i++){
        if(!(i&i>>1)){
            s[cnt++]=i;
        }
    }
    //状态计算,这里的循环到n+1的技巧同样适用 
    f[0][0] = 1;
    for(int i=1;i<=n+1;i++){
        for(int a=0;a<cnt;a++){
            for(int b=0;b<cnt;b++){
                //得到状态的信息
                if(!(s[a]&s[b])&&(s[a]&g[i])==s[a]){
                    f[i][a] = (f[i][a]+f[i-1][b])%Mod;
                }
            }
        }
    }
    cout << f[n+1][0];
    return 0;
}  
```

[327. 玉米田 - AcWing题库](https://www.acwing.com/problem/content/329/)

可以一试，对状态压缩的理解大大提高

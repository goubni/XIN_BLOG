---
title: 区间dp 石子合并
excerpt: 无
tags: dp
categories: 区间dp系列
quicklink: true
date: 2023-12-9 23:16:00

---

# 石子合并

来看一道区间dp的经典实例，有N堆石子摆成一排，其编号为1，2，...N，每一堆石子都有重量，现在要将这些石子合成一堆，每次只可以选择相邻的石子合并成一堆，每次合并要花费两堆石子之和作为代价，合并时的顺序不同，也会导致代价不同，求出使合并成一堆石子的总代价最小的代价

## 思路

假设示例为 1 3 2 4 5,最小代价可以自己计算是34

用动态规划做，我们考虑 $f[i][j]$的含义为从区间i到j的最小代价，在这个区间内打一个点k，那么$f[i][j]=f[i][k]+f[k+1][j]$，我们再不断枚举这个k，就能更新出一个区间内的总代价最值，需要先预处理出前缀和数组，在$O(1)$得出一个区间的和，需要用到前缀和数组

- 循环第一层，枚举长度，比如这个例子 len = 2，3，4，5

- 第二层枚举起始点l,l+len-1<=n,自然得出结束点 r = l+len-1

- 之后再枚举k，不断更新区间内的代价最值 $f[l][r]=max(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1])$

- 初始化，我们需要初始化，将所有f[i][j]都置为无穷大才对，(求最大不合法置为无穷小，求最小不合法置为无穷大)，特别考虑 f[1][1],f[2][2]...这些所代表的含义是将一堆石子合并，一堆石子无法合并，那代价就是0

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=110;
int n;
int a[N],s[N],f[N][N]; //f[i][i]代表在区间i到i合并石子所花的最最小费用 
//初始化是f[i][i]=0,代表在每个石子合并的费用是0 


int main(){
    memset(f,0x3f,sizeof(f));
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
        s[i] = s[i-1]+a[i];
        f[i][i]=0;
    }
    //枚举区间长度 
    for(int len=2; len<=n;len++){
        //枚举l和r
        for(int l=1;l+len-1<=n;l++){
            int r = l+len-1;
            //枚举决策
            for(int k=l;k<r;k++){
                f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);
            }
        } 
    }
    cout << f[1][n] <<endl;
    return 0;
}
```





[石子合并（弱化版） - 洛谷 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1775)



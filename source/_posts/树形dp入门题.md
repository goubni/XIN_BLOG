---
title: 树形dp 最大子树和
excerpt: 无
tags: 
categories: 树形dp系列
quicklink: true
date: 2024-3-28 23:16:00

---



# 树形dp入门题



# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 输入格式

第一行一个整数 $n\ (1\le N\le 16000)$。表示原始的那株花卉上共 $n$ 朵花。

第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 朵花的美丽指数。

接下来 $n-1$ 行每行两个整数 $a,b$，表示存在一条连接第 $a$ 朵花和第 $b$ 朵花的枝条。

## 输出格式

一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过 $2147483647$。

## 样例 #1

### 样例输入 #1

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 样例输出 #1

```
3
```

## 提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le N\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le N\le 16000$。







# 思路

这题需要转换一下更好理解，给你一颗树，树上每个结点有一个权值，问你这棵树中子树的所有权值和最大是多少？题意是要我们找到树上点权之和最大的一个连通分量，譬如满足样例的选择就是下图中框起来的一块，

![](https://cdn.luogu.com.cn/upload/pic/46078.png)



我们用$f[i]$记录以$i$为根的子树中点权和最大的一颗子树，对于每一个结点，都可以选择剪或者不剪，什么时候可以剪？当结点$u$的儿子$v$有$f[v]<0$时，就剪断这一条，否则就不剪



```cpp
#include <bits/stdc++.h>
using namespace std;
int n,w[16005],f[16005],a,b;
//f[i]代表以i为根的子树的点权和最大值 
vector<int> e[16005];

void dfs(int u,int fa){
	f[u] = w[u];
	for(int v:e[u]){
		if(v == fa) continue;
		dfs(v,u);
		if(f[v] > 0) f[u] += f[v];
	}
}

int main(){
	cin >> n;
	for(int i=1;i<=n;i++) cin >> w[i];
	for(int i=0;i<n-1;i++){
		cin >> a >> b;
		e[a].push_back(b);
		e[b].push_back(a);
	}  
	dfs(1,0);
	int ans = -99999999;
	for(int i=1;i<=n;i++) ans = max(ans,f[i]);
	cout << ans;
	return 0;
	
}
```

又优雅又难

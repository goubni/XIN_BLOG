---
title: 求符合条件的全排列的逆序对总数
excerpt: 该死的dp又磨了我一上午
tags: dp
categories: 刷题"难题"收录
quicklink: true
date: 2023-10-14 12:16:49
---

话不多说，先看题目

> ## 题目描述
> 
> 我们说(i,j) 是 a1​,a2​,⋯,aN​ 的一个逆序对，当且仅当 i<j 且 ai​>aj​。例如 [2,4,1,3,5] 的逆序对有 3 个，分别为 (1,3),(2,3),(2,4)。现在已知 N 和 K，求 1,2,3,⋯,N 的所有特定排列，使得这些排列的逆序对的数量恰好为 K。输出这些特定排列的数量。
> 
> 例如 N=5，K=3 的时候，满足条件的排列有 15 个，它们是：
> 
> - [1,2,5,4,3]；
> - [1,3,4,5,2]；
> - [1,3,5,2,4]；
> - [1,4,2,5,3]；
> - [1,4,3,2,5]；
> - [1,5,2,3,4]；
> - [2,1,4,5,3]；
> - [2,1,5,3,4]；
> - [2,3,1,5,4]；
> - [2,3,4,1,5]；
> - [2,4,1,3,5]；
> - [3,1,2,5,4]；
> - [3,1,4,2,5]；
> - [3,2,1,4,5]；
> - [4,1,2,3,5]。
> 
> ## 输入格式
> 
> 输入共第一行，两个整数 N 和 K。
> 
> ## 输出格式
> 
> 将 1⋯N 的逆序对数量为 K 的特定排列的数量输出。为了避免高精度计算，请将结果对 10000 取模后再输出。
> 
> ## 输入输出样例
> 
> ## 输入
> 
>  5 3
> 
> ## 输出
> 
>  15
> 
> ## 说明/提示
> 
> ### 数据范围及约定
> 
> 对于全部数据，保证 N≤100，K≤N×(N−1)/2。

我一拿到这题就先看数据范围，算出N最大为100的时候，K才5000不到。于是我立马想能不能用树状数组做(~~做多了树状数组是这样~~),求一个序列的逆序对花O(nlogn),但是要列出全排列，用回溯法得花O(n!)。N是100，好，直接暴毙。

~~于是再仔细一想，就想出来了~~

## 具体做法

1. N才100，那得想到是dp才能做。

2. 先定义 f[i][j] 代表序列1到i的全排列的逆序对为j的方案数，比如说f[3][2]是2,就代表序列1到3的全排列里([1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]),满足有2个逆序对的方案的总数是2 (就是 [3,1,2],[3,2,1])。这样只要推到了f[N][K]那就是答案了

3. 怎么推？

4. 首先得先搞清楚f[i]一定是由f[i - 1]转移过来的。就好比现在我有3个数，我已经确定了它们的方案数，如果此时再加进一个数，而且这个数比他们任何数都要大，那我如果将这个数不停的移动，那已有的逆序对就会发生变化。

5. 假设此时我们已经有两个数1，2。它们只有两种排列([1,2],[2,1]),此时我如果再加进一个3来：
   
   1. 如果3放在这两个数的右边，显然不会对逆序对的增加有任何帮助
   
   2. 如果放在第二个数的位置，那么此时逆序对会加1
   
   3. 如果放在第一个数的位置，那么此时逆序对会加2
   
   那该怎么表示？如果f[2][2]代表序列1到2的全排列逆序对为2的方案数，如果再加一个数，就是说 <mark>f[3][2] = f[2][2] + f[2][1] + f[2][0]</mark>
   
   怎么理解这个式子，f[2][2]就是上面的第一种情况,我已经满足你的方案数了，就是2；f[2][1]就对应上面的第二种情况，逆序对已经加1了，那我想保持住这个方案数，我就得减1；f[2][0]就对应上面的第三种情况，逆序对加2了，我就得减2才能维持住这个方案数

6. 刚刚是举例，现在就是通式：当插入的数字是在末尾的时候，逆序对就是前i-1个数的方案数，插入在倒数第二位时，逆序对就是前i-1个数的逆序对减1的方案数，一次类推

7. 得到转移方程：f[i][j] = f[i - 1][j] + f[i - 1][j - 1] + f[i - 1][j - 2] .....+f[i - 1][j - k]
   
   - 即 f[i][j]=sum(f[i−1][j−k])0≤k≤i−1

    

给出AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int N, K;
int f[101][5000];
int main()
{
    cin >> N >> K;
    f[1][0] = 1;
    f[2][1] = 1;
    f[2][0] = 1;
    f[0][0] = 1;
    for(int i = 3; i <= N; i++){
        for(int j = 0; j <= K; j++){
            for(int k = 0; k <= i - 1 && j - k >= 0; k++){
                f[i][j] = (f[i - 1][j - k] + f[i][j]) % 10000;
            }
        }
    }
    cout << f[N][K] << endl;
    return 0;
}
```

样例中 5 3 的f数组

f[2][1] = f[1][0] + f[1][1] 
f[3][1] = f[2][0] + f[2][1]
f[3][2] = f[2][0] + f[2][1] + f[2][2]
f[3][3] = f[2][1] + f[2][2] + f[2][3]
f[4][1] = f[3][0] + f[3][1]
f[4][2] = f[3][0] + f[3][1] + f[3][2]
f[4][3] = f[3][0] + f[3][1] + f[3][2] + f[3][3]
f[5][1] = f[4][0] + f[4][1]
f[5][2] = f[4][0] + f[4][1] + f[4][2]
f[5][3] = f[4][0] + f[4][1] + f[4][2] + f[4][3]
